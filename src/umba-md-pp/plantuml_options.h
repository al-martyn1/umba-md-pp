#pragma once

#include "umba/umba.h"
#include "umba/filename.h"
#include "umba/filesys.h"
#include "umba/string_plus.h"
//
#include "utils.h"
//
#include "enums.h"
//
#include <string>


// PDF на русском - https://plantuml.com/ru/guide
// Интеграция с гитлаб - https://blog.anoff.io/2018-07-31-diagrams-with-plantuml/
// Добавить опцию - как вставлять, как прямо код ```plantuml или картинкой
// VSCode плагин - PlantUML jebbs Alt+D Preview

// Примеры 
// https://plantuml.com/ru/sequence-diagram        @startuml
// https://plantuml.com/ru/use-case-diagram        @startuml
// https://plantuml.com/ru/class-diagram           @startuml
// https://plantuml.com/ru/activity-diagram-beta   @startuml
// https://plantuml.com/ru/component-diagram       @startuml
// https://plantuml.com/ru/state-diagram           @startuml
// https://plantuml.com/ru/object-diagram          @startuml
// https://plantuml.com/ru/deployment-diagram      @startuml
// https://plantuml.com/ru/timing-diagram          @startuml
// https://plantuml.com/ru/regex                   @startregex
// https://plantuml.com/ru/nwdiag                  @startuml
// https://plantuml.com/ru/salt                    @startsalt
// https://plantuml.com/ru/archimate-diagram       @startuml
// https://plantuml.com/ru/gantt-diagram           @startgantt
// https://plantuml.com/ru/chronology-diagram      @startchronology
// https://plantuml.com/ru/mindmap-diagram         @startmindmap
// https://plantuml.com/ru/wbs-diagram             @startwbs
// https://plantuml.com/ru/json                    @startjson
// https://plantuml.com/ru/yaml                    @startyaml

// Ditaa - https://plantuml.com/ru/ditaa           @startditaa
// JCCKit - https://plantuml.com/ru/jcckit         @startjcckit




struct PlantUmlOptions
{

    PlantUmlTargetFormat     targetFormat = PlantUmlTargetFormat::svg; // -tsvg
    PlantUmlDiagramType      diagramType  = PlantUmlDiagramType::uml ; 

    unsigned long            scale = 100; // 100%

    // bool                     useFilenameAutogeneration = true;
    // std::string              saveFilename = "graph";
    //  
    // static inline
    // unsigned long            autoGeneratedIndex = 0;
    //  
    // static inline
    // unsigned long            autoGeneratedTempDotIndex = 0;
    //  
    // bool                     keepTempDotFiles = false;
    //  
    std::string              savePath;
    //  
    bool                     showLabels = false;


    static
    std::string generateFileIndexString(unsigned long idx, std::size_t len=4)
    {
        std::string idxStr = std::to_string(idx);
        std::size_t numZeros = idxStr.size()>=len ? 0u : len-idxStr.size();
        //name.append(std::string(numZeros, '0') + idxStr);
        return std::string(numZeros, '0') + idxStr;
    }

    std::string makeTargetFormatCliArgument() const
    {
        return "-t" + enum_serialize(targetFormat);
    }

    bool setTargetFormat(const std::string &strTargetFormat)
    {
        auto tmp = enum_deserialize(strTargetFormat, PlantUmlTargetFormat::invalid);
        if (tmp==PlantUmlTargetFormat::invalid)
            return false;

        targetFormat = tmp;
        return true;
    }

    bool setDiagramType(const std::string &strDiagramType)
    {
        auto tmp = enum_deserialize(strDiagramType, PlantUmlDiagramType::invalid);
        if (tmp==PlantUmlDiagramType::invalid)
            return false;

        diagramType = tmp;
        return true;
    }

    std::string getSavePath() const
    {
        if (savePath.empty())
            return umba::filesys::getCurrentDirectory();

        if (!umba::filename::isAbsPath(savePath))
            return umba::filename::appendPath(umba::filesys::getCurrentDirectory(), savePath);

        return savePath;
    }

    std::string generateHashFilename() const
    {
        return umba::filename::appendPath(getSavePath(), std::string("$puml-hash$.txt"));
    }

    std::string generateOutputFilename(bool flattenImageLinks) const
    {
        std::string name;

        if (useFilenameAutogeneration)
        {
            name = saveFilename + "_";
            // std::string idxStr = std::to_string(autoGeneratedIndex++);
            // std::size_t numZeros = idxStr.size()>=4u ? 0u : 4u-idxStr.size();
            // name.append(std::string(numZeros, '0') + idxStr);
            name.append(generateFileIndexString(autoGeneratedIndex++, 4));
        }
        else
        {
            name = saveFilename;
        }

        // SVG не масштабируем при помощи DPI, выходит лажа - размер вроде тот же, а картинка больше, в итоге часть обрезается. SVG и так норм отображается
        if (targetFormat!=GraphVizTargetFormat::svg)
        {
            name.append("_");
            name.append(std::to_string(getScaledDpi()));
        }

        name = umba::filename::appendExt(name, enum_serialize(targetFormat));
        if (flattenImageLinks)
        {
            name = umba::filename::flattenPath(name);
        }

        return umba::filename::appendPath(getSavePath(), name);
    }

    std::string generateInputTempFilename() const
    {
        if (!keepTempDotFiles)
            return umba::filename::appendPath(getSavePath(), std::string("$temp$.puml"));
        else
            return umba::filename::appendPath(getSavePath(), std::string("$temp_") + generateFileIndexString(autoGeneratedTempDotIndex++) + "$.puml");
    }

    std::string generateOutputTempFolderName() const
    {
        return umba::filename::appendPath(getSavePath(), std::string("$temp$_")enum_serialize(targetFormat));
    }


    // std::string makeDotDpiCliArgument() const
    // {
    //     //return escapeCommandLineArgument("-Gdpi=" + std::to_string(getScaledDpi()));
    //     return "-Gdpi=" + std::to_string(getScaledDpi());
    // }

    template<typename FilenameStringType>
    bool generateCommandLineArgs( const AppConfig<FilenameStringType> &appCfg
                                , std::string &tool
                                , std::vector<std::string> &args
                                , const std::string &inputPumlFile
                                , const std::string &outputImageFolder
                                ) const
    {
        // https://plantuml.com/ru/command-line
        auto java        = appCfg.getJava();
        auto plantUmlJar = appCfg.getPlantUml();
        if (java.empty() || plantUmlJar.empty())
            return false;

        
        tool = java;

        args.emplace_back("-jar");
        args.emplace_back(plantUmlJar);
        args.emplace_back("-o");
        args.emplace_back(outputImageFolder);
        args.emplace_back(makeTargetFormatCliArgument());
        args.emplace_back(inputPumlFile);
        return true;
    }


    void setSaveFileName(const std::string &name)
    {
        useFilenameAutogeneration = false;
        saveFilename = name;
    }

    #if 0
    unsigned long getScaledDpi() const
    {
        // SVG не масштабируем при помощи DPI, выходит лажа - размер вроде тот же, а картинка больше, в итоге часть обрезается. SVG и так норм отображается
        if (targetFormat==GraphVizTargetFormat::svg)
            return 96;
        return dpi*scale / 100ul;
    }
    #endif

    #if 0
    bool setDpi(const std::string &dpiStr) // --gviz-dpi
    {
        try
        {
            dpi = std::stoul(dpiStr);
            return true;
        }
        catch(...)
        {
            return false;
        }
    }
    #endif

    bool setScale(std::string strScale)
    {
        try
        {
            if (umba::string_plus::ends_with_and_strip(strScale, ("%")))
            {
                umba::string_plus::trim(strScale);
                scale = std::stoul(strScale);
                return true;
            }
            else
            {
                auto dblScale = std::stod(strScale);
                if (dblScale<=0.0)
                    return false;
                scale = (unsigned long)(dblScale*100);
                return true;
            }
        }
        catch(...)
        {
            return false;
        }
    }
    #endif


};



