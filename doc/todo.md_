---
Title: Известные проблемы и TODO
---

#!toc

# Приоритетные направления

 - [ ] Извлечение фрагментов кода
 - [ ] Директивы UMBA-MD-PP
 - [ ] HTML-директивы
 - [ ] Графы DOT
 - [ ] Таблицы CSV


# Важные задачи в библиотеках

 - [ ] Генерация доки в MD по параметрам командной строки. Также нужно скрестить это с подсистемой переводов TR. 
       Нужно генерить и рыбу переводов (в формате JSON/XML). В командной строке нужно добавить опции `--help-lang`, 
       `--help-fish-translation-format`, `--help-generate-fish`.
 - [ ] В подсистеме перекодировки нужно уметь получать текущую кодировку мультибайтного (ANSI) API.
       Нужно уметь получать кодировку консоли для вывода (а для баш какая?)
       Нужно уметь получать кодировку консоли для ввода (такая же, как для вывода? а для баш какая?)


# Философия

  - [ ] Запилить тему про систематизацию знаний. Привет, велкин. Систематизировать знания можно и нужно.
        Систематизация знаний - это то, что отличает homo sapience от других homo и других sapience.


# TODO List

  - **Графы (DOT)**

    - [ ] Начало графа: `<dot dpi=NN file=MMMM.dot>` или `<dot dpi=NN> MMMM.dot` (`<dot> MMMM.dot`) - если задано имя файла, обрабатываем его содержимое, как если оно у нас в документе. 
          Если имени нет, считаем, что последующие строки до строки `</dot>` - это граф.
    - [ ] DPI - Если просто число - это абсолютное значение. Если `xN.NN` - множитель, `NN%` - множитель в процентах. 
    - [ ] Множители применяются к базовому DPI, которое задаётся опцией командной строки `--dot-dpi`. Базовый DPI какой задать? 72 - совсем плохо и мелко, 96 - чуть лучше, 120 - ещё чуть лучше.
          У меня - монитор Q27P2W: 27" 2560 x 1440, 16:9, sqrt(2560*2560+1440*1440)=2937 диагональных пикселей на 27 дюймов - 108 пикселей на дюйм.
          Другой: 1920 x 1080 24", sqrt(1920*1920+1280*1280) = 2307 диагональных пикселей на 24 дюйма, 96 пикселей на дюйм.
    - [ ] Или без всякого DPI, чтобы не смущать юзера, просто атрибут `scale`?
    - [ ] Поиск DOT - пока хз, если не найдено, то вызываем просто командой dot без пути.
    - [ ] `--dot-target-format=SVG/PNG`.
    - [ ] Имя генерируемого файла: если DOT-файл задан, меняем на расширение формата, и кладём рядом с DOT-файлом. Иначе автогенерим DOTXXXXX.ext и кладем в каталог `--dot-output-root`/`--dot-output-path`. 
          В документ вставляем относительный путь (относительно текущего обрабатываемого документа). Но у нас же может быть генерация в разные форматы, с разным DPI? Тогда к имени файла ещё добавляем 
          получившееся (с масштабированием) разрешение.
    - [ ] Может тэг - `graph`? Он используется в какой-то вики как родной - http://lib.custis.ru/Graphviz. Там неплохой набор примеров.

    
  - **Таблицы**

    - [ ] Надо уточнить, как эксель сохраняет в CSV, выделяется ли заголовок
    - [ ] Упрощённые таблицы из CSV - используем тэг <csv> для начала и </csv> - для окончания - строка начинается данного тэга.
          После стартового тэга может идти дополнение - строка таблицы с выравниванием (это всё в одно строчку - тэг и формат).
    - [ ] В матстатистику по автоопределению разделителя не играем - лень. По умолчанию разделитель - ',' (запятая, 'c'/'C' - comma). 
          Разделитель можно указать после открывающего тэга, перед строкой выравнивания.
          Можно использовать ';'('s'/'S' - semicolon). Можно использовать 't'/'T' - символ табуляции.
          Пример: `<csv>;|:-|-|:-:|-:|` - разделитель: точка с запятой, выравнивание: слева, по-центру, по-центру, справа.
          Это используется для всей таблицы, включая заголовки.
    - [ ] В CSV файле/данных может не быть заголовка. тогда нам надо задать его самим, например, так:
          `<csv>;{|:No|Наименование|:Ед. Изм.:|Количество:|}|:-|-|:-:|-:|` - в фигурных скобках - заголовок таблицы с выравниванием ячеек заголовка, 
          выравнивание остальной таблицы следует далее.
    - [ ] Можно задавать для заголовка только выравнивание. 
          Тогда в фигурных скобках должны быть только маркеры выравнивания ячеек (`{|:-|-|:-:|-:|}`), и ничего больше.
          В этом случае первая строка CSV является заголовком.
    - [ ] После вышеописанной упрощенной форматной строки через пробел можно задать имя файла. Тогда мы не ищем конечный тэг </csv>, а считываем содержимое файла и преобразуем в таблицу.
    - [ ] Можно задать параметры таблицы атрибутами тега: <csv header=|:-|-|:-:|-:| body=|:-|-|:-:|-:| file=NNNN.csv>, но упрощенный формат всё равно будет проверяться.
    - [ ] В форматной строчке ячеек таблицы на базе CSV не должны использоваться символы '|' как символы содержимого.
    - [ ] Если в CSV ячейка пустая, надо писать пробел, иначе будет colspan.
    - [X] Строка таблицы всегда начинается на символ '|' и заканчивается на него
    - [ ] Для каждой ячейки таблицы делаем процессинг как для отдельной строки. Или нет, плохая идея? Надо подумать.
    - [ ] Надо разобраться с row/col-span'ами, как они для гитхаба/гитлаба/доксигена делаются, и вывести какой-то универсал, который рендерить в соотв. бекэнд.
    - [ ] Таблицы в Doxygen-маркдаун - https://www.doxygen.nl/manual/markdown.html#md_tables
          * Таблицы отделяем пустой строкой от остального;
          * Заголовок отделяется строкой, содержащей ячейки '---';
          * Выравнивание - ':';
          * row span - крышка ('^');
          * col span - пустой текст.
    - [ ] Таблицы в GitHub-маркдаун - https://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting/organizing-information-with-tables
          * Таблицы отделяем пустой строкой от остального;
          * Заголовок отделяется строкой, содержащей ячейки '---';
          * Выравнивание - ':';
          * Проверить - row span - крышка ('^') - не работает - https://stackoverflow.com/questions/23571724/github-markdown-colspan;
          * Проверить - col span - пустой текст - не работает - https://stackoverflow.com/questions/23571724/github-markdown-colspan.


  - **Извлечение фрагментов кода**

    - [X] Извлечение фрагментов кода: задавать фрагмент не парой строк, а начальной строкой и до парной скобки, т.е. начался фрагмент, 
          каждая '{' увеличивает счетчик, каждая '}' - уменьшает, и когда он возвращается в ноль, фрагмент кода заканчивается. Символы 
          скобок, являющихся блочными маркерами, задавать в описании языка. Если не задано, то значит, такой тип включения нам не доступен.
    - [X] Извлечение фрагментов кода: задавать стартовую позицию блока номером строки, и маркером, с которого строка должна начинаться.
          Для поиска маркера с определенной позиции, но не раньше. Маркер - как уточнение, в текст/код могут вносится изменения, и номер
          строки "поедет". Доп. маркер позволяет пережить это. Многострочный маркер? Нормализация маркера: табы заменяются пробелами, 
          пробелы сжимаются до одного. Или вообще выкидывать табы и пробелы?
    - [X] Извлечение фрагментов кода: извлечение кода до разделителя. Стандартно (для C/C++) это строка, начинающаяся c `//---`.
    - [X] Извлечение фрагментов кода: извлечение кода до N пустых строк.
    - [ ] Извлечение фрагментов кода: откат начала назад по тексту до пустой строки перед фрагментом.
    - [ ] Извлечение фрагментов кода: извлечение прототипа. Задаются допустимые в прототипе типы скобок, задаётся маркер окончания прототипа - ';'. 
          Первые скобки в списке допустимых скобок - основные. Когда счетчик основных скобок доходит до нуля (но при этом все доп. скобки также 
          должны быть по нулям) - считываем пока не встречаем маркер конца прототипа (или дополнительный break-символ, для плюсов это ':'), 
          или не встречаем начало блока.
    - [X] Извлечение фрагментов кода: сырые маркеры. Многострочный маркер. Нормализованый маркер. Маркер начала и конца отделяются дефисом-минусом.


  - **Директивы UMBA-MD-PP**

    - [ ] Сделать директивы if/else/elseif/elif с упрощенным синтаксисом выражений, аналогично CMake
    - [ ] HTML-директивы (csv, dot, etc) - сделать простецкий разбор HTML тэга (одного) для строк, которые начинаются с символа '<', и заканчивается разбор на символе '>'. 
          Если никаких ошибок не произошло, то считаем данную строку корректным HTML тэгом.
          Атрибуты - в кавычках и без. Имена тэгов и атрибутов - латиница и цифры, подчеркивание и минус.


  - **Макроподстановки**

    - [X] Сделать макроподстановку в именах файлов, включаемых по insert
    - [ ] Макроподстановка в тексте - надо ли? Надо ли её отключать? Надо ли управлять режимом макроподстановки для различных фрагментов текста?
    - [X] Macro names register matter - регистр символов в имени макросов имеет значение. По умолчанию, без включения опций 
          smf_uppercaseNames/smf_lowercaseNames регистр имён макросов имеет значение. В командной строке макросы также задаются
          с учётом регистра. И переделывать это не хочется - потому что вероятны ситуации, когда мы захотим сделать такие макросы:
          `Somemacro` -> `Something`,
          `somemacro` -> `something` и
          `SOMEMACRO` -> `SOMETHING`.
          Например, для подстановок в тексте, в начале предложения или ещё как-то.          
          Но, хорошо бы задавать из командной строки макросы, которые потом обрабатываются без учёта регистра.
          Тогда задаём в командной строке макрос SOME_VAR так: `--set-var=^Some_Var:SomeValue`. Символ "крышки" говорит нам о том, что
          эту переменную можно использовать без учёта регистра. При добавлении такой переменной мы добавляем отображение `Some_Var`->`SomeValue`,
          и дополнительно отображение `^SOME_VAR`->`SomeValue`. При поиске, если обломались найти `Some_Var`, то меняем регистр символов на верхний,
          и добавляем "крышку", после чего пробуем искать снова. Тут надо будет переделать поисковик значений переменных, сейчас используется
          стандартный umba::macros::MacroTextFromMapOrEnvRef - в принципе, делов на три копейки. Само-собой, никакая локализация в именах
          макросов не работает, только латиница.
#//    - [ ] 


  - **Командная строка**

    - [ ] Надо сделать так, чтобы файл опций `.md-pp.options`, который аффектится на все файлы в текущем каталоге и его подкаталогах, читался
          до разбора командной строки, и все опции из него применялись, кроме, возможно, `--batch-scan` и `--batch-scan-recurse`.
          Но это возможно только тогда, когда произведён разбор командной строки, и мы получили имя обрабатываемого файла. Надо обдумать.

  
  - **Свои расширения Markdown**

    - [ ] Сделать разбор текста, и выцепить -abcdef- (sub) и -^abcdef- (sup)
    - [ ] Процессинг делаем построковый, переносить конструкции на другую строку нельзя (это пока, дальше будет видно).
    - [ ] Сделать разбор XML-тэгов. Рекурсивно вложенные теги не поддерживаем. При появлении символа '<' начинаем патыться найти стартовый тэг, если успешно,
          то конечный. Стартовый тэг не содержит пробелы, только латинница и символы минус и подчеркивание. Конечный тэг ищется также, только имя тэга должно
          начинаться с символа деления. Никаких атрибутов, и тп. Ищем только в тексте.
    - [ ] Тэги: epigraph, может содержать author (или без автора, но может содержать cite?); cite - цитата, может содержать author; тэг для стихов - посмотреть в FB2;
          figure и тп. Но вообще - это не срочно, и, возможно, это стоит отложить на потом, когда соберусь делать свой рендерер.
    - [ ] Или упрощённый вариант XML-тэгов - начальный и конечный тэг - всегда на отдельной строке? В принципе, вполне в духе markdown.


  - **Поддержка фич GitHub flavored markdown для доксигена (и не только)**

    - [ ] [GitHub Flavored Markdown Spec](https://github.github.com/gfm/)
    - [ ] [Markdown Cheatsheet](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet).
          Вставка ютуба - `[![IMAGE ALT TEXT HERE](http://img.youtube.com/vi/YOUTUBE_VIDEO_ID_HERE/0.jpg)](http://www.youtube.com/watch?v=YOUTUBE_VIDEO_ID_HERE)`
    - [ ] Разобраться, что гитхаб считает как block quote, а что - нет. См. block_quote_test.md. Гитхаб [считает](https://github.com/al-martyn1/umba-md-pp/blob/main/tests/block_quote_test.md)
          BQ1-BQ3 и следующую бла бла за один блок, BQ4/5/6 - отдельные. Доксиген считает, что первая BQ - это BQ3, и вторая это BQ6. То есть, block quote надо в любом случае
          подшаманивать. В целом, гитхаб считает, что если строка начинается с символа > - это block quote, даже если нет пробела от предыдущего параграфа. Но от последующего 
          надо отделять пустой строкой, иначе он считается как продолжение block quote. Уровень block quote считается по первой строке. Пробелы до и после символов > гитхаб 
          игнорирует, что не скажешь о доксигене. Листинг и хидер брикают блок-квоту.
    - [ ] Сделать события на block quote - первая строчка block quote, просто строчка block quote, конец block quote - в последнем случае будет передаваться 
          фейковая строка, которая не будет добавлятся в документ.
    - [ ] На базе событий block quote запилить обработчик github-alerts
    - [ ] Как работают списки на гитхабе. Сколько бы пробельных символов не было после последнего элемента списка, если далее следует строка того же уровня списка 
          и с тем же маркером, то список продолжается. Прерывается список пустой строкой, за которой следует что-то другое.
          Уровень списка может начинаться с нулевой позиции, не обязательно у верхнего списка делать отступ.
    - [ ] Разобраться, как работают списки в доксигене. Листинг - не прерывает список, а входит элемент списка. Заголовок прерывает. Нумерация в нумерованных списках в доксигене должна возрастать.
    - [ ] Маркеры списка - -/*/+, после них - пробел
    - [ ] Нумерованный список начинается с цифры, затем точка, затем пробел
  


  - **Обработка ссылок на внешние документы и картинки**

    - [X] Надо сканировать ссылки на картинки, и создавать список картинок. Их необходимо копировать в выходной каталог, если он отличается от входного.
    - [X] При включении документов картинки в нем заданы относительно него, пути к ним надо подправить, чтобы они правильно указывали, так как 
          включаемый файл может находится в другом каталоге.
    - [X] Процессинг ссылок/картинок делаем построковый, мало кто ссылки переносит на несколько строк (если такое вообще можно).
    - [X] Ссылки на внешние документы/картинки процессим в процессе insert-doc (коррекция пути).
    - [X] Меняем входные (и только их) расширения `.md_` и аналогичные на выходные `.md`.
    - [X] Сделать ссылки на картинки плоскими - без разделителей пути и спец-имён каталогов (--flatten-image-links). Работает только при копировании картинок.
          Всегда работает для вьювера при подготовке файлов для доксигена.
    - [ ] Сделать рекурсивный разбор ссылок.
    - [ ] Если ссылка локальная и содержит якорь - то якорь надо переработать согласно правилам рендерера - доксиген или гитхаб. Надо будет ещё проверить GitLab-рендерер.


  - **Вьювер**

    - [X] Надо сделать регистрацию вьювера как обработчика расширений .md, ._md, .md_, .markdown, ._markdown, .markdown_
    - [X] бага в генерации id для секций под доксиген - вместо подчеркивания появляется символ 0x7F
    - [ ] Сделать поиск окна ворда с текущим файлом, и закрытие его
    - [ ] Похоже, ссылки на разделы документа парсяться неправильно (или не всегда правильно), получается что-то типа 
          `[Общедоступные стайл-гайды](common_style_guides)[Общедоступные стайл-гайды](#)`
    - [ ] В генерируемом оглавлении откуда-то появляются анчоры в фигурных скобках
          `[Общедоступные стайл-гайды [extra.style-guides] {#common_style_guides}](#obshchedostupnye-stayl-gaydy--extra-style-guides----common-style-guides)`
    - [X] Сделать фичу - viewer копирует сгенерированный для просмотра документ в локацию исходного .md/.md_ файла, с тем же именем и расширением rtf. 
          В качестве опции можно задавать имя файла, транслитерированное из заголовка документа.
    - [X] Если опция копирования задана, то открываем документ уже в исходной локации, чтобы можно было сразу подредактировать его и сохранить.


  - **Язык и его определение**

    - [X] Уметь парсить обозначения языков, включая их естественные названия (без учета регистра), превращая их в идентификаторы. По этим идентификаторам
          мы и будем вставлять локализованные Note, Tip, Important, Warning, Caution (будет группа github-alerts).
    - [X] По этому lang-id также будем задавать язык для доксигена
    - [X] Язык документа можно определять по тэгу Language в документе, или новой опцией --document-language=ru, --lang=ru
    - [X] Принудительно переопределяем язык документа опцией --force-document-language=ru, --force-lang=ru
    - [X] Генерация корректного русского документа доксигеном возможна, только если задан язык - русский. Иначе генерит мусор.
          Надо в дефолтные опции добавить опцию --document-language=russian, чтобы по дефолту нормально генерились русские документы (английские это не испортит).
    - [X] --processing-options=transliterate-generated-filenames надо поместить в дефолтные опции.
    - [X] При генерации имени временного каталога кроме хэша использовать исходное имя файла, возможно, с какой-то частью пути, чтобы было проще понять, 
          к какому файлу относится этот временный каталог. Сделал без части пути.


  - **Имена входных и выходных файлов**

    - [X] если не задан выходной файл, проверяем входной файл. Если начинается на точку, то просто убираем лидирующую точку. Если расширение начинается 
          или заканчивается на '_' - убираем этот символ
    - [X] генерация имени файла по имени документа - не забываем, что char у нас знаковый
    - [X] Задание входных родных расширений для MDPP через опцию командной строки - 
          сделал опцию `--add-mdpp-extention`/`--add-mdpp-extention` - 
          задаём в дефолтном и/или юзерском конфиге обрабатываемые расширения. Они (и также без подчериваний) используются при регистрации вьювера.


  - **batch-режим**

    - [X] Сканирование в batch-режиме производится по расширениям, заданным для MDPP опцией `--add-mdpp-extention`/`--add-mdpp-extention`.
    - [X] Выходные имена файлов (при batch режиме, а также при обычном режиме, если не задано имя выходного файла) формируются на основании
          имени выходного файла путем обрезания ведущих и завершающих символов подчеркивания ('_').
    - [X] Опция `--batch-exclude-dir`/`--batch-exclude-dirs` - имя/имена каталогов (без пути), которые игнорируются при обходе
          каталогов. Не является маской. Является именем каталога без пути. В стандартной конфигурации совпадает с поддерживаемыми MDPP-расширениями.
          В таких каталогах лежат файла, которые не являются самостоятельными документами, а предназначены только для включения в другие документы.
    - [X] Опция `--batch-exclude` - маска для исключения файлов из обработки.
    - [X] Опции `--batch`/`--batch-recurse`/`--rbatch` - сканирование (рекурсивное) каталогов на предмет поиска файлов для обработки.
          Данная опция включает пакетный режим.
    - [X] Опция `batch-output-root`/`batch-output-root-path` - каталог для выходных файлов пакетного режима, если не задан, используется входной каталог.
          У каждого файла есть относительный путь до корневого каталога сканирования, и он будет применяться при записи файла в выходной каталог,
          если тот задан. Если выходной каталог не задан, результирующий файл будет записан в исходный каталог.
#//    - [ ] 


  - **Разное**

    - [X] проверить, относительно чего считаются пути в опции --add-examples-path - если опция встречается 
          в .options-файле, то относительные пути должны отсчитываться от него
    - [X] по умолчанию в --set-insert-options не стоит опция fail, и проблемы молча съедаются. Может, я давно не обновлял дистр?
    - [X] по умолчанию в --set-insert-options не стоит опция path - неудобно
    - [X] по умолчанию в --set-insert-options не стоит опция filenameLineNo - неудобно
    - [X] сделать тип генерируемого конента - --target-format=rtf, и в этом режиме, если --target-renderer=doxygen, устанавливать
          опцию ProcessingOptions::parse-github-alerts (но её можно установить и ручками). Данная опция должна делать обычный параграф, и вставлять
          слова Note, Tip, Important, Warning, Caution или их локализованные варианты.
          https://docs.github.com/ru/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#alerts
          https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#alerts
  
