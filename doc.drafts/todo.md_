---
Title: Известные проблемы и TODO
---

#!toc

# Приоритетные направления

- [X] Извлечение фрагментов кода
- [ ] Директивы UMBA-MD-PP
- [X] HTML-директивы
- [X] Графы DOT
- [X] Графы PlantUML - аналогично DOT
- [ ] Таблицы CSV


# Важные задачи в библиотеках

- [X] Генерация доки в MD по параметрам командной строки. 
- [ ] Также нужно скрестить генерацию MD по параметрам ком строки с подсистемой переводов TR.
      Нужно генерить и рыбу переводов (в формате JSON/XML). В командной строке нужно добавить опции `--help-lang`,
      `--help-fish-translation-format`, `--help-generate-fish`.
- [X] В подсистеме перекодировки нужно уметь получать текущую кодировку мультибайтного (ANSI) API.
      Нужно уметь получать кодировку консоли для вывода (а для баш какая?)
      Нужно уметь получать кодировку консоли для ввода (такая же, как для вывода? а для баш какая?)
- [X] Сделать filesys::utf - умеет работать со всеми типами строк, широкими и char/string, char/string перекодирует в широкие.
      Добавить кучу перегрузок каждой функции, чтобы можно было использовать и std::(w)string и char/wchar_t* строки и тд и тп.
      Используем UMBA_FILESYS_UTF_SYSAPI_HAS_WIDE_VERSION для определения того, есть ли wide версия API.
- [ ] Рыбоконь - научить выводить в MD
- [X] Brief Scanner - научить выводить в MD


# Buddy-проекты

**Таблица готовности buddy-проектов**

|Проект|CMake Ready|WERR MSVC Ready|WERR GCC Ready|
|:---  |:---       |:---:|:---:|
|umba-2c||||
|umba-brief-scanner|X|X|X|
|umba-cl-msg|X|X|X|
|umba-dll-proxy-gen||||
|umba-enum-gen|X|X|X|
|umba-fsm|X|||
|umba-hcp|X|||
|umba-make-headers||||
|umba-md-pp|X|||
|umba-pretty-headers|CMake not required|||
|umba-roboconf|X|||
|umba-sort-headers||||
|umba-subst-macros|x|||
|umba-tabtool||||
|umba-tr||||


## umba-hide (umba-hide-dot-files)

Сканирует текущий каталог и все файлы и каталоги, имена которых начинаются с точки, делает скрытыми.
Используется виндовый атрибут `hidden`.

Проводник

- [ ] `-h`/`--hide[=true|false]` - по этой опции производится прятание `.dot` файлов и каталогов - все `.dot` 
      файлы и каталоги делаются видимыми или нет.

- [ ] `-u`/`--unhide` - аналог `--hide=false`.

- [ ] `--open` - открывается указанный или текущий каталог в проводнике.

- [ ] `-s`/`--shell-hide[=true|false]` - в проводнике включается режим "не отобржать скрытые файлы и папки".

- [ ] --make-self-alias[=NAME] - делает хардлинк на себя с именем NAME. Хардлинк - софт линки в винде 
      запрещены почему-то. Если NAME не задано, то используем `uhdf` (первоначальное название утилиты - 
      `umba-hide`, а сокращение и линк, соответственно `uh` - это веселее, но слишком коротко и подвержено 
      опасности коллизий и случайного набора).


## umba-cl-msg 

- [ ] сделать разбор опций командной строки и добавить возможность добавлять типа для замены при помощи опций.
      Пример: 
          std::basic_string<char,std::char_traits<char>,std::allocator<char>>          -> std::string
          std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> -> std::wstring


## umba-brief-scanner

- [ ] Сделать сканирование плюсовых сорцов на наличие маркеров TODO/UNDONE/NOTE
  (UNDONE - 1) noun отменено 2) adjective незаконченный).
  Можно добавлять свои, например, ATTENTION/ATTE
  Можно добавлять алиасы: ATTE->ATTENTION, !!!->ATTENTION

- [ ] При этом в тексте примечаний (уже с удалённым префиксом типа заметки) следует удалять '!!!' - я так часто 
  дополнительно маркирую TODO-шки и другие типы замечаний, чтобы они все находились тупым поиском.

- [ ] Сохранение коллекции тудушек и остального - либо в явно заданный каталог, и тогда там создаются файлы
  todo-auto.md_, undone-auto.md_, note-auto.md_, содержищие все найденные заметки, либо такой набор создаётся
  в каждом каталоге с сорцами

- [ ] Задавать расширение имени файла для генерируемых тудушек.
  
- [ ] В тудушке или другой заметке может быть признак маркера [ ]/[X] - он переносится в результирующий файл.

- [ ] Для каждого типа заметок надо задавать формат вывода - либо это маркдаунный TODO, либо как-то по другому.

- [ ] Если у нас многострочный коммент, в нем не может быть несколько заметок.

- [ ] Если у нас одноострочный коммент, то заметка может продолжаться в следующем однострочном комменте. 
      Прерывается пустой строкой.

- [ ] Но, если у нас одноострочный коммент, то в следующем однострочном коменте может быть новая заметка.


## umba-modify-user-env (umue)

Тулза для задания переменных окружения текущего пользователя (под винду, пока, а там видно будет).

- [ ] --add[-var]=VAR:VALUE - добавляет переменную, или фейлится, если переменная есть.

- [ ] --update[-var]=VAR:VALUE - изменяет переменную, или фейлится, если переменной нет.

- [ ] --add-or-update[-var]=VAR:VALUE - добавляет или изменяет переменную.

- [ ] --path-modify - модифицирует переменную PATH. Модифицирует символы '/' в символы '\' 
      (в винде, и наоборот в других системах). Поверяет, нет ли уже такого пути в PATH, при этом каждый 
      элемент PATH канонизируется по слешам, и проверка производится без учета регистра (винда) для двух
      вариантов - со слэшем на конце и без него.

- [ ] --make-self-alias[=NAME] - делает хардлинк на себя с именем NAME. Хардлинк - софт линки в винде 
      запрещены почему-то. Если NAME не задано, то используем `umue`.


## umba-enum-gen

- [ ] Когда у нас ничего нет для генерации, кроме голенького enum, нам не надо вставлять макрос про то,
      является ли enum флаговым или обычным.

- [ ] Если у нас голенький enum, но enum class, нам нужны определения из `cstdint`.


# Направление движения

Сейчас у нас есть несколько недоделанных направлений.

- [ ] Язык для рисования. Хорошо бы сделать, он нужен.
- [ ] Язык для описания пакетов протоколов. Стырить мармаидный синтаксис, сделать совместимым. Мармаид нам не годится, 
      они рисует в браузере. Хорошо бы сделать, он нужен.
- [ ] Сборка TODO - поиск среди исходников файлов TODO и формирование единого TODO. Фича полезная. Не нужно вести один 
      большой TODO по проекту, с другой стороны, после сборки всё в одном файле.
- [ ] Сайдбар. Пока не особо нужно, надо начать пилить доку, и смотреть, что и как там с вики будет получаться.
- [ ] Собственно, дока по препроцессору. Пора бы уже начинать пилить.

Надо подумать, что нам нужно в первую очередь.



#/*
# Философия

- [ ] Запилить тему про систематизацию знаний. Привет, велкин. Систематизировать знания можно и нужно.
      Систематизация знаний - это то, что отличает homo sapience от других homo и других sapience.
#*/

# TODO List


## Сборка TODO

- [X] `--processing-options` - добавляем опцию `todo`/`no-todo` - для обработки тудушек в пакетном режиме и генерации выходного
      `TODO`. Все остальные опции включаются, если задана данная `processing`-опция.
- [ ] `--todo-batch-scan=...` - задаём путь для сканирования на предмет `todo.md_`.
      Для каждой системы/подсистемы, располагающейся в отдельном каталоге с исходными текстами, может быть заведён свой `todo.md_`.
- [ ] `--todo-name=...` - задаём имя TODO-файла (без расширения, расширения используются такие же, как и для обычного md-pp файла).
      Если расширение задано, то используем только его, иначе проверяем все известные расширения. Или, может, файлы могут иметь 
      двойное расширение? А зачем бы нам двойное расширение?
      Таких опций может быть много, проверяем по всему списку, после первого найденного останавливаемся.
- [ ] `--todo-output-name=...` - задаём имя выходного файла, может содержать относительный путь. При обработке опции запоминаем 
      текущий каталог, и если не задан `--batch-output-root` - используем сохраненный каталог, как корневой, иначе используем 
      каталог `--batch-output-root`.
      Если расширения нет, устанавливаем расширение `.md`.
- [X] Генерировать препроцессированный `todo.md` рядом с исходным `todo.md_` - не нужно.
- [ ] TODO-файл - не препроцессится, как обычный `.md_` файл. Никакие директивы не обрабатываются, он является
      чистым `MD` файлом.
- [ ] В TODO-файле может использоваться своя семантика, какие-то идентификаторы тикетов, дата задания тикета, 
      ожидаемое время реализации, фактическое время реализации, ссылка на story, ссылка на артефакты.
      Эта семантика пока не проработана, надо посмотреть на тулзу `AbstractSpoon` `ToDoList` (расширение `.tdl`).
      Посмотреть `work/carno/tasks` для примера.
- [ ] В TODO-файле могут быть только заголовки, и списки задач. Списки задач могут быть иерархическими, т.е. вложенными.
      Ничего больше в TODO-файле быть не должно.
- [ ] В TODO-файле могут быть заголовки. Может не быть главного заголовка - какая-то преамбула, а потом сразу подразделы.
      Тогда назначаем заголовок по относительному пути от каталога поиска.
- [ ] Вопрос с заголовками в TODO-файле надо наверное поглубже проработать.
- [ ] Если главный заголовок есть, то к нему добавляем в круглых скобках относительный путь от каталога поиска.
- [ ] Делаем raise заголовков так, чтобы они были заголовками минимум второго уровня в результирующем TODO.


## DocumentID

- [ ] Добавить тэг Document-ID - руками присваивается уникальный ID в рамках проекта, и никогда больше не меняется,
      как бы документ не менялся, и не менялось его название и/или имя файла. А то при переименованиях, даже незначительных,
      приходится все ссылки поправлять.
- [ ] В batch-режиме сначала сканируем все файлы и создаём базу Document-ID -> { Имя файла, Заголовок документа}.
- [ ] Ссылаемся на такой документ при помощи специального маркера `$` в начале ссылки, вместо которой подставляем реальное имя файла.
      Заодно тут можно и пробелы пофиксить, и предупреждение о круглых скобках в имени файла выдать.
- [ ] При ссылке на ID документа можно в тексте ссылки (не в линке, в линке - ID) использовать `$filename`, тогда будет вставлено 
      название документа, `$title` - заголовок
- [ ] Тэг не наследуется, не дополняется, не переопределяется, может быть извлечён только из основного обрабатываемого документа -
      наверное, надо новый тип тэгов заводить.


## Сайдбар и футер

- [ ] GitHub и GitLab поддерживают `_Sidebar.md`. 
     В [доке](https://docs.github.com/ru/communities/documenting-your-project-with-wikis/creating-a-footer-or-sidebar-for-your-wiki)
     GitHub'а приведен пример с большой буквой. В [доке](https://docs.gitlab.com/ee/user/project/wiki/) по GitLab имя аналогичное, 
     но с маленькой буквы. Тем не менее, GitLab поддерживает имя файла сайдбара и с большой буквы (проверил). Формат файла зависит 
     от расширения, `.md` - это обычный маркдаун.
- [ ] Футер. GitHub поддерживает `_Footer.md`. GitLab - "The wiki functionality in GitLab is based on Gollum 4.x" - Gollum вроде 
     поддерживает футеры (надо проверить). 
- [ ] Генерацию сайдбаров делаем так: создаем в папке файл с именем `.sidebar`. В нем - упрощённый синтаксис, разрешены заголовки 
     `#` и элементы списка `-`. Продолжение элемента на следующей строке не поддерживается. Если не было встречено заголовка, то 
     список не сворачивается. Если был заголовок, то он становится содержимым `<details>/<summary>`. Элементы списка добавляются 
     как `LI` в `UL` в теле `<details>`.


## Processing Options (--processing-options)

- [ ] а не перетащить ли все флаговые опции в `--processing-options`?
- [X] Сделать возможность отключения опции не только как `no-OPTION`, но и просто как `-OPTION`.
- [X] удаляем минусы из processing-option - у нас десериализуется и без них, но микс, когда есть не все - не пройдёт.


## Директивы UMBA-MD-PP


### Включение произвольных текстов 

- [X] `#!insert{quote}` - включаем файл и оформляем как blockquote.
- [X] `#!insert{quote,pre}` - включаем файл и оформляем как блок `pre`.
- [ ] `#!insert{quote,pre}` - для `pre` надо иметь возможность удалять строки с тройными бэктиками в начале, если они 
      располагаются первой и последней строкой. А зачем?


### Переменные и условные операторы

- [ ] `#!set{}`. Сделать директиву set - она устанавливает значение conditional переменной: `#!set{VarName, Value}`: Value может 
      быть идентификатором, числом, или строковым литералом в одинарных или двойных кавычках. Это нужно, чтобы принудительно 
      задавать переменные перед подключением других файлов, которые их используют.
- [ ] `#!set{}`. Директива `set` работает только на текущий файл. Это про batch-режим. Перед обработкой каждого файла в batch-режиме 
      надо делать push для всех переменных, а после - pop.
- [ ] `sidebar`
- [ ] Сделать директивы `if`/`else`/`elseif`/`elif` с упрощенным синтаксисом выражений, аналогично CMake
- [X] HTML-директивы (csv, dot, etc) - сделать простецкий разбор HTML тэга (одного) для строк, которые начинаются с символа '<', 
      и заканчивается разбор на символе '>'. Если никаких ошибок не произошло, то считаем данную строку корректным HTML тэгом.
      Атрибуты - в кавычках и без. Имена тэгов и атрибутов - латиница и цифры, подчеркивание и минус.


### Switch

- [ ] `switch`. Пока не сделаны директивы `if`/`else`/`elseif`/`elif` - делаем директивы `switch()`/`case()`/`default()`/`endswitch()`.
      Идея такая: в директиве `switch()` задаём имя переменной. В директивах `case()` задаём возможные значения. Если 
      совпало со значением в указанной переменной, то вставляется фрагент текста, следующий за данным `case()` до следующего 
      `case()`/`default()`/`endswitch()`. Если ничего не сработало, вставляется то, что после метки `default()`, если она есть.
      `break()` не нужен. Директива `fallthrough()` в теле `case()`? Или `case-ft()`/`case-fallthrough()`? Лучше второе, меньше 
      директив. Это если мы хотим перескочить на метку, пропустив начало, и вставить всё остальное. Может быть удобно.
- [ ] `switch`/`case-fallthrough-all` (`case-ft-all`). `case-fallthrough()` проваливается о следующего `case()` или `case-fallthrough()`. 
      Если встречается `case()`, а не `case-fallthrough-all()`, то обработка выскакивает из `switch`. Если встречается `case-fallthrough()`,
      то обработка продолжается до следующего `case()`, и так далее. Для того, чтобы вставить весьб текст от сработавшей метки до конца 
      `switch` (но не включать то, что в секции `default()`), используем директиву `case-fallthrough-all()` - при этом текст до 
      соответствующего `case-fallthrough-all()` пропускается, и вставляется весь текст после.
- [ ] `switch`. Как можно вставить всё? Наверное, это специальный режим, задаём из командной строки - `--switch-all[=true]`
- [ ] `switch`. Нужно получить список переменных, используемых в `switch`, и список из возможных значений, а также все места, где 
      встречается как `switch`, так и `case()`/`case-fallthrough()`. Это у нас будет `--switch-report=format,filename`, где `format` -
      `md`/`txt`. Или отдельные опции - `--switch-report=filename` `--switch-report-format=format`? А можно и так и так.
- [ ] `switch`. После каждого `switch`/`case()`/`case-fallthrough()` может идти текст. Этот текст будет выдаваться в интерактивном режиме.
      Тогда заводим ключик `--switch=X`, где `X`: `all` - выводим весь текст свичей, `case` - нормальный режим работы с выбором по метке, 
      `interract` - интерактивный режим - запускается TUI с выбором вариантов. В TUI есть первый вариант выбора `Show all` с пометкой, 
      что это только отображает в интерфейсе все варианты, выбрать его нельзя (или можно?), а затем идут варианты из `case()`/`case-fallthrough()` 
      с их текстовыми метками. TUI - это уже высший пилотаж, пока нацелюсь на автоматическую обработку, и не забыть про отчет со списком.
- [ ] `switch`. Вложенные `switch` не поддерживаются.


### Detailing

- [ ] `detailing`. По директиве `switch` напрашивается вариант использования - уровень детализации. Детализация подразумевает,
      что в начале идут базовые сведения, затем более и более подробные, в зависимости от заданного уровня детализации. А сейчас наоборот -
      по метке мы выбираем вариант из списка, и можем проваливаться к более детальной информации, пропустив вводную. Заведем тогда другую 
      конструкцию - `detailing()`/`break()`/`enddetailing()`. Тут мы выводим всё, что у нас есть, пока не встретим директиву `break()` 
      с подходящим значением. Допустим, у нас есть уровни детализации: brief, standard, detailed, extra. Пишем обзор - текст, потом 
      `break(brief)`. Далее - стандартное описание, завершаем директивой `break(standard)` - вроде бы то, что именно, что нужно.
- [ ] `detailing`. Ссылки про уровень детализации: 
      https://en.wikipedia.org/wiki/Level_of_detail, https://en.wikipedia.org/wiki/Level_of_detail_(writing)


### Checklist

- [ ] `checklist`. Перечисление/список фрагментов документа, которые мы хотим включить в результирующий документ.
- [ ] `checklist`. Задаём переменную `NNN` со всеми вариантами - `AA|BB|CC|DD`
- [ ] `checklist`. В чек-листе используем директиву `check{AA}`/`check{BB}` и тп. Если чек срабатыает, то вставляем соотв. фрагмент.


### Switch/Detailing/If

- [ ] Обработку директив `#!switch`/`#!detailing` для каждого документа делаем на предварительном этапе: так, для корневых документов 
      будут использоваться переменные, заданные из командной строки, а для подключаемых документов будут также аффектится переменные, 
      устанавливаемые директивой `#!set`.
- [ ] Вероятнее всего, что директивы `#!if` и аналогичные будут работать так же.




## Метаданные документов

### #!meta - вставка метатегов в документ в виде текста

- [X] `#!meta`. Данная директива вставляет метаданные документа в тело документа в виде текста. Директива `#!meta` 
       вставляет те метаданные, которые которые заданы в командной строке.
- [X] `#!meta`. Цель - вставлять в документ данные из метатегов. Пример использования: GitLab отображает метатеги при 
      просмотре документа в вики, но при печати "As PDF File" метатеги не печатаются. При печати и отдаче бумажной копии 
      мне хочется, чтобы на ней был адрес страницы в гитлабе. Можно включить в браузере печать колонтитулов, там адрес 
      печатается, но колонтитул печатается вплотную к краям листа, и при "слепой" зоне принтера в пару мм колонтитулы 
      уже не прочитать. Поэтому решено добавить возможность вставлять метатеги в документ, отбивая их от тела документа
      горизонтальным разделителем. Метатеги в тело документа вставляются по возможности в самое начало, если они не 
      вставляются явно.
- [X] `#!meta`. Опция командой строки `--document-meta-tags=author,url` - задаёт список метаданных, которые будут вставлены 
      в документ по запросу (опцией командной строки или директивой `#!meta` без параметров).
- [X] `#!meta`. Опция командой строки `--document-add-meta-tags[=true]` - явно задаёт вставить метатеги в тело документа
      (а не в метатеги). UPD: добавил опции `--processing-options`: `insert-meta`/`no-insert-meta`, 
      `force-insert-meta`/`no-force-insert-meta`.
- [X] `#!meta`. Директива `#!meta{author,url}` вставит записи `author` и `url` вне зависимости от того, что задано в конфиге 
      из командной строки.
- [X] `#!meta`. Нужен перевод имён метатегов на язык документа. Сделать через `tr` фичу.
- [X] `#!meta`. Заголовок секции метатегов в документе: "Информация о документе"/"Document Information". Оформляем болдом, 
      а не заголовком. Добавил в --processing-options опции document-meta-title/no-document-meta-title. Эти опции также можно 
      использовать в директиве #!meta{} как один из тэгов в списке.
- [X] `#!meta`. Вставка метатэгов в документ. Метатеги при вставке в документ обрамляются строкой-сепаратором - `---`. 
      Если метатеги идут в документе самыми первыми, то стартового сепаратора `---` не должно быть, иначе он будет воспринят 
      именно как метаинфа документа, а не как содержимое документа. При генерации оглавления страницы (`toc`) вставка метатегов 
      должна производится после вставки оглавления. Сепаратор `---` нормально отрабатывается гитхабом, надо проверить на гитлабе.
- [X] `#!meta`. Нужно добавить фичу макроподстановок в метатегах. Тогда мы задаём в командной строке `DocumentBaseURL`/`BaseURL` 
      и можем его использовать в метатеге "URL". Сделал фичу `auto-url`, добавил специальную задаваемую пользователем переменную 
      `__DocumentBaseUrl`, и автоматически задаваемую переменную `__DocumentRelFileName`. Вопрос с автоматическим заданием тега 
      `URL` решен, а вроде бы для чего-то другого и не нужно, и сейчас всё нормас.


### Auto-URL - автоматическая генерация метатега URL

- [X] При пакетной обработке автоматически задаем переменную `__DocumentRelFileName` - путь к документу относительно каталога поиска,
      в котором он найден. Расширение убирается, если стоит опция обрезки расширений.
- [X] Добавляем processing option - `auto-url` - и тогда, если задана переменная `__DocumentBaseUrl`, и если нет тэга URL,
      то он автоматически добавляется.
- [X] Сделать `root-only` тип метатега - когда метатэг может быть задан только непосредственно в обрабатываемом документе,
      а не в одном из подключаемых (в подключенных - игнорируется). Такой тэг только как текст, не список/набор любого вида.
      Вроде сделал, но это не точно.
- [X] В какой момент проверять наличие тэга URL и при отсутствии генерить автоматически - пока не понял. Теперь понял, и запилил.


### Метаданые во внешних файлах Graphviz и PlantUML

- [X] `gvp-meta`. `Graphviz` - коментарий сишный, `//`, метаинфа в `Graphviz` начинается с `//---` в самом начале файла.
- [X] `gvp-meta`. `PlantUML` - коментарий - одинарная кавычка, `'`, метаинфа в `Graphviz` начинается с `'---` в самом начале файла.
- [X] `gvp-meta`. Метаинфа `Graphviz`/`PlantUML` заканчивается точно так же, как начинается.
- [X] `gvp-meta`. Пробелы в концах строк игнорируются.
- [X] `gvp-meta`. Метаинфа в `Graphviz`/`PlantUML` файлах внутри begin/end мета-сепараторов должна начинаться с одного префикса.
- [X] `gvp-meta`. Метаинфа в `Graphviz`/`PlantUML` после удаления специфики `Graphviz`/`PlantUML` является метаинфой в формате YAML.


## Simple Drawing

- [ ] `smpd`. Очень простое рисование
- [ ] `smpd`. Делаем похоженько на PlantUML
- [ ] `smpd`. Сноски: `footnote`, обозначаются минусами `-`.
- [ ] `smpd`. Сноски: налево: `/---` - вверх налево (восходящий символ первый ); `\---` - вниз налево (нисходящий символ первый)
- [ ] `smpd`. Сноски: направо: `---/,` - вверх направо (восходящий символ последний); `---\` - вниз направо (нисходящий символ последний)
- [ ] `smpd`. Сноски: `<---` - горизонтальная налево, `--->` - горизонтальная направо.
- [ ] `smpd`. Сноски: `---` - горизонтальная налево, краткая запись для `<---`
- [ ] `smpd`. Сноски: `|---` - вертикальная вниз, `|^---` - вертикальная вверх.
- [ ] `smpd`. Сноски: Точка `.` - переход в горизонтальный подчерк только после базового направления сноски (см. выше).
- [ ] `smpd`. Сноски: `---` - горизонтальный подчерк.
- [ ] `smpd`. Сноски: длина сноски и горизонтального подчерка зависит от числа минусов.
- [ ] `smpd`. Сноски: сначала задаётся направление и длина сноски, потом опциональная точка "перелома", потом - "подчерк".
- [ ] `smpd`. "/---.-------" - сноска налево вверх длиной три условных пункта, потом к ней горизонтальная площадка длиной 
      7 условных пунктов, текст сноски будет над площадкой. Если площадки нет - текст будет прицеплен к концу линии сноски
      по центру линии сноски.
- [ ] `smpd`. Сноски: "/---()" - сноска, будет вставлено автогенерируемое число (подчерк игнорируется)
- [ ] `smpd`. Сноски: "/---(Текст)" - сноска, будет вставлено автогенерируемое число (подчерк игнорируется)
- [ ] `smpd`. Сноски: "/---(X/N)" - сноска, X/N - число, заданное явно (подчерк игнорируется)
- [ ] `smpd`. Примеры языка. frame #black 15; set default
- [ ] `smpd`. Примеры языка. fill #red; set default
- [ ] `smpd`. Примеры языка. Прямоугольник: rect (Lx,Ty,Sx,Sy)
- [ ] `smpd`. Примеры языка. Прямоугольник: rect (Lx,Ty), (Rx, By)
- [ ] `smpd`. Примеры языка. Прямоугольник со скруглением 0.5: roundrect (Lx,Ty,Sx,Sy), 0.5
- [ ] `smpd`. Примеры языка. Прямоугольник со скруглением 0.5: roundrect (Lx,Ty), (Rx, By), 0.5
- [ ] `smpd`. Примеры языка. roundrect ... rotate -90
- [ ] `smpd`. Примеры языка. circle (x,y), 15 rotate 720
- [ ] `smpd`. Примеры языка. font "Tahoma" 14
- [ ] `smpd`. Примеры языка. circle (x,y), 15 rotate 720 font "Tahoma" 14; Хотя зачем тут фонт для циркли?
- [ ] `smpd`. Примеры языка. circle (x,y), 15 rotate 720 font "Tahoma" 14 repeat (2,15),(0.25,3) frame #green 10 fill #blue
- [ ] `smpd`. Примеры языка. circle (x,y), 15 rotate 720 font "Tahoma" 14 repeat (2,15),(0.25,3) : /---.----(текст)
              Прокрутили цирклю два раз вокруг своей оси, сделали две копии по горизонтали и 15 копий по вертикали), к первой
              копии сделали сноску с текстом вверх налево.


## Командная строка и .md-pp.options файлы опций

  Предлагаемая схема с многоуровневой иерархией файлов опций должна позволить в пакетном режиме обрабатывать все файла за раз,
  применяя к каждому файлу индивидуальный иерархический набор опций.

- [X] `.md-pp.options` и `umba-md-pp.options` - обрабатываем только один из них, предпочтение для `.md-pp.options`. Или оба?
- [X] Надо сделать так, чтобы файл опций `.md-pp.options`, который аффектится на все файлы в текущем каталоге и его подкаталогах,
      читался до разбора командной строки, и все опции из него применялись, кроме, возможно, `--batch-scan` и `--batch-scan-recurse`.
      Но это возможно только тогда, когда произведён разбор командной строки, и мы получили имя обрабатываемого файла. Надо обдумать.
      Обдумал. Нет. Batch-опции задаются из командной строки, а все умолчательные конфиги применяются к конкретному файлу.
- [X] Ищем все `.md-pp.options`, не останавливаясь на первом найденном файле. Поиск производим до самого корня (диска или файловой 
      системы, зависит от).
- [X] Останавливаемся при поиске наверх по нахождению файла `.md-pp.base.options` - почему base - потому что порядок обработки -
      обратный поиску, и файл опций `base` будет первым в обработке, остальные файла его переопределят.
- [X] Первым проверяемым именем является имя файла без оригинального расширения с расширением `.md-pp.options` - там лежат опции 
      для конкретного файла. Данный файл ищется только в том же каталоге, в котором расположен и исходный файл.
- [X] Для md-pp-view ищем также файлы `.md-pp-view.options` и `umba-md-pp-view.options`. Они вместо, после или до обрабатываются?
      Надо обдумать.
- [X] Пути поиска снипетов для включения. В рамках одного конфиг-файла они должны добавлятся в хвост.
      Но с учетом списка конфигов, когда последние конфиги переопределяют первые, пути должны добавлятся в начало списка путей.
      Идея такая. При обработке конфига пушим (push) список "инклюд-каталогов", добавляем в конец свежеочищенного, потом делаем
      pop и тут можно спопленное либо в начало, либо в конец добавлять.
- [X] Как генерить для wiki? У нас есть генерация не инплейс, а в стороннюю папочку. Но пока особых различий нет между этими
      вариантами. А если мы хотим генерить для разных вики с разными настройками каждого файла?
      Допустим, пути поиска сниппетов от типа цели не зависят.
      А что зависит? Возможно, какие-то on/off опции.
      Тогда делаем ключик `--wiki=WIKITYPE` (он работает только в командной строке). При наличии такого ключика мы начинаем 
      также искать все файлы вида `.md-pp.wiki-WIKITYPE.options` и `umba-md-pp.wiki-WIKITYPE.options` и подобные.
- [ ] Добавить опцию `--viewer-processing-options` - всё аналогично `--processing-options`, но обрабатывает её только вьювер.
      Тогда мы можем задать `--processing-options` только для вьювера, например, `force-insert-meta`, чтобы в текст документа
      принудительно вставлялись метатеги, когда мы используем вьювер,
      и нам не надо ручками писать отдельный конфиг для вьювера. Утилита командной строки эти опции просто игнорирует.
- [ ] Добавить опцию `--viewer-document-meta-tags` - всё аналогично `--document-meta-tags`, но обрабатывает её только вьювер.
      Тогда мы можем задать список вставляемых тэгов для вьювера отдельно,
      и нам не надо ручками писать отдельный конфиг для вьювера. Утилита командной строки эти опции просто игнорирует.
- [ ] Мы научились иметь метаданные в файлах graphviz и PlantUML (`gvp-meta`) и извлекать их оттуда. Теперь нам надо подумать о том,
      как включать или выключать извлечение метаданных из внешних файлов graphviz и PlantUML.


## Снипеты

### Извлечение снипетов из кода

- [X] Извлечение фрагментов кода: задавать фрагмент не парой строк, а начальной строкой и до парной скобки, т.е. начался фрагмент,
      каждая '{' увеличивает счетчик, каждая '}' - уменьшает, и когда он возвращается в ноль, фрагмент кода заканчивается. Символы
      скобок, являющихся блочными маркерами, задавать в описании языка. Если не задано, то значит, такой тип включения нам не доступен.
- [X] Извлечение фрагментов кода: задавать стартовую позицию блока номером строки, и маркером, с которого строка должна начинаться.
      Для поиска маркера с определенной позиции, но не раньше. Маркер - как уточнение, в текст/код могут вносится изменения, и номер
      строки "поедет". Доп. маркер позволяет пережить это. Многострочный маркер? Нормализация маркера: табы заменяются пробелами,
      пробелы сжимаются до одного. Или вообще выкидывать табы и пробелы?
- [X] Извлечение фрагментов кода: извлечение кода до разделителя. Стандартно (для C/C++) это строка, начинающаяся c `//---`.
- [X] Извлечение фрагментов кода: извлечение кода до N пустых строк.
- [X] Извлечение фрагментов кода: откат начала назад по тексту до пустой строки перед фрагментом. (Мысль не была раскрыта, что хотелось,
      уже забыто, помечаем как готово).
- [ ] Извлечение фрагментов кода: извлечение прототипа. Задаются допустимые в прототипе типы скобок, задаётся маркер окончания прототипа - ';'.
      Первые скобки в списке допустимых скобок - основные. Когда счетчик основных скобок доходит до нуля (но при этом все доп. скобки также
      должны быть по нулям) - считываем пока не встречаем маркер конца прототипа (или дополнительный break-символ, для плюсов это ':'),
      или не встречаем начало блока.
- [X] Извлечение фрагментов кода: сырые маркеры. Многострочный маркер. Нормализованый маркер. Маркер начала и конца отделяются дефисом-минусом.


### Включение снипетов в документ

- [ ] Сейчас сниппеты включаются только из каталогов, которые явно заданы в командной строке.
      Надо добавить фичу, чтобы сниппеты включались по пути относительно текущего документа.
- [ ] Опция командной строки `--relative-snippets[=true|false]`
- [ ] Если `--relative-snippets=true`, то относительный путь должен проверяться первым.
- [ ] Надо вспомнить, как правильно использовать тэги для выкусывания произвольных фрагментов кода


### Автоформатирование снипетов

- [ ] Фича нужная, потому что код, откуда выцепляем примеры - обычно полное говно, отформатированное через жопу, а в документацию примеры кода
      мы хотим вставлять красивые.
- [ ] Для каждого включаемого снипета (примера кода) можно запускать автоформаттер кода, в зависимости от типа файла, откуда выкусываем фрагмент.
- [ ] В автоформаттер кода нужно как-то передавать параметры форматирования. Обдумать.
- [ ] Автоформаттеры - артистик стайл и шланг-формат. Прежде всего они. Это для C/C++.
- [ ] Фича нужная, но не необходимая. Пока подождёт.


## Графы (DOT)

- [X] Начало графа: `<dot dpi=NN file=MMMM.dot>` или `<dot dpi=NN> MMMM.dot` (`<dot> MMMM.dot`) - если задано имя файла, обрабатываем его 
      содержимое, как если оно у нас в документе. Если имени нет, считаем, что последующие строки до строки `</dot>` - это граф.
- [X] DPI - Если просто число - это абсолютное значение. Если `xN.NN` - множитель, `NN%` - множитель в процентах.
- [X] Множители применяются к базовому DPI, которое задаётся опцией командной строки `--dot-dpi`. Базовый DPI какой задать? 72 - 
      совсем плохо и мелко, 96 - чуть лучше, 120 - ещё чуть лучше.
      У меня - монитор `Q27P2W`: `27" 2560 x 1440`, `16:9`, `sqrt(2560*2560+1440*1440)=2937` диагональных пикселей на 27 дюймов - 
      108 пикселей на дюйм.
      Другой: `1920 x 1080`, `24"`, `sqrt(1920*1920+1280*1280) = 2307` диагональных пикселей на 24 дюйма, 96 пикселей на дюйм.
- [X] Или без всякого DPI, чтобы не смущать юзера, просто атрибут `scale`?
- [X] Поиск DOT - пока хз, если не найдено, то вызываем просто командой dot без пути.
- [X] `--dot-target-format=SVG/PNG`.
- [X] Имя генерируемого файла: если DOT-файл задан, меняем на расширение формата, и кладём рядом с DOT-файлом. Иначе автогенерим 
      DOTXXXXX.ext и кладем в каталог `--dot-output-root`/`--dot-output-path`.
      В документ вставляем относительный путь (относительно текущего обрабатываемого документа). Но у нас же может быть генерация 
      в разные форматы, с разным DPI? Тогда к имени файла ещё добавляем
      получившееся (с масштабированием) разрешение.
- [X] Может тэг - `graph`? Он используется в какой-то вики как родной - http://lib.custis.ru/Graphviz. Там неплохой набор примеров.
- [X] Можно проверить сист переменную GVBINDIR
- [X] Путь в реестре - Компьютер\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Graphviz\Graphviz
      Компьютер\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\Graphviz
- [X] Нужно добавить разбор атрибутов HTML-тэгов в кавычках (никаких entity, и кавычку в такой атрибут не вставить)
- [X] разбор атрибутов HTML-тэгов в кавычках вроде добавил, но вроде есть баги
- [X] Дополнения в MD - после тэга можем искать имя файла - оно тоже может быть в кавычках, и точно также нельзя использовать 
      кавычки внутри.
- [X] После тэга может идти и заголовок генерируемой картинки - он тоже либо в кавычках, либо без, от имени файла отличается воскл. 
      знаком в начале (если с кавычками, то он внутри). Нормальный порядок - `имя_файла Заголовок из одного или нескольких слов`. 
      Если имя файла задано - заголовок читается до конца строки и можно без кавычек, если имя файла не задано, то заголовок должен 
      начинаться с воскл знака.
- [X] Не лазать в реестр слишком часто - не более одного раза для каждой программы за запуск.
- [X] Опции --dont-lookup-for-doxygen[=false], --dont-lookup-for-graphviz[=false] - не искать в реестре пути к этим программам, 
      надеяться, что они лежат в путях.
- [X] Сделать однократный AllocConsole для гуёвой тулзы, чтобы system ловило её, а не создавало для себя каждый раз отдельное 
      консольное окно.
- [X] Атрибут `type` - добил enum'ов, вызываются разные graphviz-тулзы по этому тэгу.


## Таблицы

- [ ] Надо уточнить, как эксель сохраняет в CSV, выделяется ли заголовок
- [ ] Упрощённые таблицы из CSV - используем тэг <csv> для начала и </csv> - для окончания - строка начинается данного тэга.
      После стартового тэга может идти дополнение - строка таблицы с выравниванием (это всё в одно строчку - тэг и формат).
- [ ] В матстатистику по автоопределению разделителя не играем - лень. По умолчанию разделитель - ',' (запятая, 'c'/'C' - comma).
      Разделитель можно указать после открывающего тэга, перед строкой выравнивания.
      Можно использовать ';'('s'/'S' - semicolon). Можно использовать 't'/'T' - символ табуляции.
      Пример: `<csv>;|:-|-|:-:|-:|` - разделитель: точка с запятой, выравнивание: слева, по-центру, по-центру, справа.
      Это используется для всей таблицы, включая заголовки.
- [ ] В CSV файле/данных может не быть заголовка. тогда нам надо задать его самим, например, так:
      `<csv>;{|:No|Наименование|:Ед. Изм.:|Количество:|}|:-|-|:-:|-:|` - в фигурных скобках - заголовок таблицы с выравниванием 
      ячеек заголовка,
      выравнивание остальной таблицы следует далее.
- [ ] Можно задавать для заголовка только выравнивание.
      Тогда в фигурных скобках должны быть только маркеры выравнивания ячеек (`{|:-|-|:-:|-:|}`), и ничего больше.
      В этом случае первая строка CSV является заголовком.
- [ ] После вышеописанной упрощенной форматной строки через пробел можно задать имя файла. Тогда мы не ищем конечный тэг </csv>, 
      а считываем содержимое файла и преобразуем в таблицу.
- [ ] Можно задать параметры таблицы атрибутами тега: <csv header=|:-|-|:-:|-:| body=|:-|-|:-:|-:| file=NNNN.csv>, 
      но упрощенный формат всё равно будет проверяться.
- [ ] В форматной строчке ячеек таблицы на базе CSV не должны использоваться символы '|' как символы содержимого.
- [ ] Если в CSV ячейка пустая, надо писать пробел, иначе будет colspan.
- [X] Строка таблицы всегда начинается на символ '|' и заканчивается на него
- [ ] Для каждой ячейки таблицы делаем процессинг как для отдельной строки. Или нет, плохая идея? Надо подумать.
- [ ] Надо разобраться с row/col-span'ами, как они для гитхаба/гитлаба/доксигена делаются, и вывести какой-то универсал, 
      который рендерить в соотв. бекэнд.
- [ ] Таблицы в Doxygen-маркдаун - https://www.doxygen.nl/manual/markdown.html#md_tables
      * Таблицы отделяем пустой строкой от остального;
      * Заголовок отделяется строкой, содержащей ячейки '---';
      * Выравнивание - ':';
      * row span - крышка ('^');
      * col span - пустой текст.
- [ ] Таблицы в GitHub-маркдаун - https://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting/organizing-information-with-tables
      * Таблицы отделяем пустой строкой от остального;
      * Заголовок отделяется строкой, содержащей ячейки '---';
      * Выравнивание - ':';
      * Проверить - row span - крышка ('^') - не работает - https://stackoverflow.com/questions/23571724/github-markdown-colspan;
      * Проверить - col span - пустой текст - не работает - https://stackoverflow.com/questions/23571724/github-markdown-colspan.


## Макроподстановки

- [X] Сделать макроподстановку в именах файлов, включаемых по insert
- [ ] Макроподстановка в тексте - надо ли? Надо ли её отключать? Надо ли управлять режимом макроподстановки для различных фрагментов текста?
- [X] Macro names register matter - регистр символов в имени макросов имеет значение. По умолчанию, без включения опций
      smf_uppercaseNames/smf_lowercaseNames регистр имён макросов имеет значение. В командной строке макросы также задаются
      с учётом регистра. И переделывать это не хочется - потому что вероятны ситуации, когда мы захотим сделать такие макросы:
      `Somemacro` -> `Something`,
      `somemacro` -> `something` и
      `SOMEMACRO` -> `SOMETHING`.
      Например, для подстановок в тексте, в начале предложения или ещё как-то.
      Но, хорошо бы задавать из командной строки макросы, которые потом обрабатываются без учёта регистра.
      Тогда задаём в командной строке макрос SOME_VAR так: `--set-var=^Some_Var:SomeValue`. Символ "крышки" говорит нам о том, что
      эту переменную можно использовать без учёта регистра. При добавлении такой переменной мы добавляем отображение `Some_Var`->`SomeValue`,
      и дополнительно отображение `^SOME_VAR`->`SomeValue`. При поиске, если обломались найти `Some_Var`, то меняем регистр символов на верхний,
      и добавляем "крышку", после чего пробуем искать снова. Тут надо будет переделать поисковик значений переменных, сейчас используется
      стандартный umba::macros::MacroTextFromMapOrEnvRef - в принципе, делов на три копейки. Само-собой, никакая локализация в именах
      макросов не работает, только латиница.
#//- [ ]


## Свои расширения Markdown

- [ ] Сделать разбор текста, и выцепить -abcdef- (sub) и -^abcdef- (sup)
- [ ] Процессинг делаем построковый, переносить конструкции на другую строку нельзя (это пока, дальше будет видно).
- [ ] Сделать разбор XML-тэгов. Рекурсивно вложенные теги не поддерживаем. При появлении символа '<' начинаем патыться найти стартовый тэг, если успешно,
      то конечный. Стартовый тэг не содержит пробелы, только латинница и символы минус и подчеркивание. Конечный тэг ищется также, только имя тэга должно
      начинаться с символа деления. Никаких атрибутов, и тп. Ищем только в тексте.
- [ ] Тэги: epigraph, может содержать author (или без автора, но может содержать cite?); cite - цитата, может содержать author; тэг для стихов - посмотреть в FB2;
      figure и тп. Но вообще - это не срочно, и, возможно, это стоит отложить на потом, когда соберусь делать свой рендерер.
- [ ] Или упрощённый вариант XML-тэгов - начальный и конечный тэг - всегда на отдельной строке? В принципе, вполне в духе markdown.


## Поддержка фич GitHub flavored markdown для доксигена (и не только)

- [ ] [GitHub Flavored Markdown Spec](https://github.github.com/gfm/)
- [ ] [Markdown Cheatsheet](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet).
      Вставка ютуба - `[![IMAGE ALT TEXT HERE](http://img.youtube.com/vi/YOUTUBE_VIDEO_ID_HERE/0.jpg)](http://www.youtube.com/watch?v=YOUTUBE_VIDEO_ID_HERE)`
- [ ] Разобраться, что гитхаб считает как block quote, а что - нет. См. block_quote_test.md. Гитхаб [считает](https://github.com/al-martyn1/umba-md-pp/blob/main/tests/block_quote_test.md)
      BQ1-BQ3 и следующую бла бла за один блок, BQ4/5/6 - отдельные. Доксиген считает, что первая BQ - это BQ3, и вторая это BQ6. То есть, block quote надо в любом случае
      подшаманивать. В целом, гитхаб считает, что если строка начинается с символа > - это block quote, даже если нет пробела от предыдущего параграфа. Но от последующего
      надо отделять пустой строкой, иначе он считается как продолжение block quote. Уровень block quote считается по первой строке. Пробелы до и после символов > гитхаб
      игнорирует, что не скажешь о доксигене. Листинг и хидер брикают блок-квоту.
- [ ] Сделать события на block quote - первая строчка block quote, просто строчка block quote, конец block quote - в последнем случае будет передаваться
      фейковая строка, которая не будет добавлятся в документ.
- [ ] На базе событий block quote запилить обработчик github-alerts
- [ ] Как работают списки на гитхабе. Сколько бы пробельных символов не было после последнего элемента списка, если далее следует строка того же уровня списка
      и с тем же маркером, то список продолжается. Прерывается список пустой строкой, за которой следует что-то другое.
      Уровень списка может начинаться с нулевой позиции, не обязательно у верхнего списка делать отступ.
- [ ] Разобраться, как работают списки в доксигене. Листинг - не прерывает список, а входит элемент списка. Заголовок прерывает. Нумерация в нумерованных списках в доксигене должна возрастать.
- [ ] Маркеры списка - -/*/+, после них - пробел
- [ ] Нумерованный список начинается с цифры, затем точка, затем пробел


## Обработка ссылок на внешние документы и картинки

- [X] Надо сканировать ссылки на картинки, и создавать список картинок. Их необходимо копировать в выходной каталог, если он отличается от входного.
- [X] При включении документов картинки в нем заданы относительно него, пути к ним надо подправить, чтобы они правильно указывали, так как
      включаемый файл может находится в другом каталоге.
- [X] Процессинг ссылок/картинок делаем построковый, мало кто ссылки переносит на несколько строк (если такое вообще можно).
- [X] Ссылки на внешние документы/картинки процессим в процессе insert-doc (коррекция пути).
- [X] Меняем входные (и только их) расширения `.md_` и аналогичные на выходные `.md`.
- [X] Сделать ссылки на картинки плоскими - без разделителей пути и спец-имён каталогов (--flatten-image-links). Работает только при копировании картинок.
      Всегда работает для вьювера при подготовке файлов для доксигена.
- [ ] Сделать рекурсивный разбор ссылок.
- [ ] Если ссылка локальная и содержит якорь - то якорь надо переработать согласно правилам рендерера - доксиген или гитхаб. Надо будет ещё проверить GitLab-рендерер.
- [ ] Разобраться со ссылками, содержащими нелатинские символы, а также пробелы.


## Вьювер

- [X] Надо сделать регистрацию вьювера как обработчика расширений .md, ._md, .md_, .markdown, ._markdown, .markdown_
- [X] бага в генерации id для секций под доксиген - вместо подчеркивания появляется символ 0x7F
- [ ] Сделать поиск окна ворда с текущим файлом, и закрытие его
- [ ] Похоже, ссылки на разделы документа парсяться неправильно (или не всегда правильно), получается что-то типа
      `[Общедоступные стайл-гайды](common_style_guides)[Общедоступные стайл-гайды](#)`
- [ ] В генерируемом оглавлении откуда-то появляются анчоры в фигурных скобках
      `[Общедоступные стайл-гайды [extra.style-guides] {#common_style_guides}](#obshchedostupnye-stayl-gaydy--extra-style-guides----common-style-guides)`
- [X] Сделать фичу - viewer копирует сгенерированный для просмотра документ в локацию исходного .md/.md_ файла, с тем же именем и расширением rtf.
      В качестве опции можно задавать имя файла, транслитерированное из заголовка документа.
- [X] Если опция копирования задана, то открываем документ уже в исходной локации, чтобы можно было сразу подредактировать его и сохранить.


## Язык и его определение

- [X] Уметь парсить обозначения языков, включая их естественные названия (без учета регистра), превращая их в идентификаторы. По этим идентификаторам
      мы и будем вставлять локализованные Note, Tip, Important, Warning, Caution (будет группа github-alerts).
- [X] По этому lang-id также будем задавать язык для доксигена
- [X] Язык документа можно определять по тэгу Language в документе, или новой опцией --document-language=ru, --lang=ru
- [X] Принудительно переопределяем язык документа опцией --force-document-language=ru, --force-lang=ru
- [X] Генерация корректного русского документа доксигеном возможна, только если задан язык - русский. Иначе генерит мусор.
      Надо в дефолтные опции добавить опцию --document-language=russian, чтобы по дефолту нормально генерились русские документы (английские это не испортит).
- [X] --processing-options=transliterate-generated-filenames надо поместить в дефолтные опции.
- [X] При генерации имени временного каталога кроме хэша использовать исходное имя файла, возможно, с какой-то частью пути, чтобы было проще понять,
      к какому файлу относится этот временный каталог. Сделал без части пути.


## Имена входных и выходных файлов

- [X] если не задан выходной файл, проверяем входной файл. Если начинается на точку, то просто убираем лидирующую точку. Если расширение начинается
      или заканчивается на '_' - убираем этот символ
- [X] генерация имени файла по имени документа - не забываем, что char у нас знаковый
- [X] Задание входных родных расширений для MDPP через опцию командной строки -
      сделал опцию `--add-mdpp-extention`/`--add-mdpp-extention` -
      задаём в дефолтном и/или юзерском конфиге обрабатываемые расширения. Они (и также без подчериваний) используются при регистрации вьювера.


## batch-режим

- [X] Сканирование в batch-режиме производится по расширениям, заданным для MDPP опцией `--add-mdpp-extention`/`--add-mdpp-extention`.
- [X] Выходные имена файлов (при batch режиме, а также при обычном режиме, если не задано имя выходного файла) формируются на основании
      имени выходного файла путем обрезания ведущих и завершающих символов подчеркивания ('_').
- [X] Опция `--batch-exclude-dir`/`--batch-exclude-dirs` - имя/имена каталогов (без пути), которые игнорируются при обходе
      каталогов. Не является маской. Является именем каталога без пути. В стандартной конфигурации совпадает с поддерживаемыми MDPP-расширениями.
      В таких каталогах лежат файла, которые не являются самостоятельными документами, а предназначены только для включения в другие документы.
- [X] Опция `--batch-exclude` - маска для исключения файлов из обработки.
- [X] Опции `--batch`/`--batch-recurse`/`--rbatch` - сканирование (рекурсивное) каталогов на предмет поиска файлов для обработки.
      Данная опция включает пакетный режим.
- [X] Опция `batch-output-root`/`batch-output-root-path` - каталог для выходных файлов пакетного режима, если не задан, используется входной каталог.
      У каждого файла есть относительный путь до корневого каталога сканирования, и он будет применяться при записи файла в выходной каталог,
      если тот задан. Если выходной каталог не задан, результирующий файл будет записан в исходный каталог.
- [X] Пофиксить генерируемый файл git-add.bat - сделать вывод в UTF-8 и добавить включение UTF-8 в батнике (см. папку git-add)
#//- [ ]


## Разное

- [X] проверить, относительно чего считаются пути в опции --add-examples-path - если опция встречается
      в .options-файле, то относительные пути должны отсчитываться от него
- [X] по умолчанию в --set-insert-options не стоит опция fail, и проблемы молча съедаются. Может, я давно не обновлял дистр?
- [X] по умолчанию в --set-insert-options не стоит опция path - неудобно
- [X] по умолчанию в --set-insert-options не стоит опция filenameLineNo - неудобно
- [X] сделать тип генерируемого конента - --target-format=rtf, и в этом режиме, если --target-renderer=doxygen, устанавливать
      опцию ProcessingOptions::parse-github-alerts (но её можно установить и ручками). Данная опция должна делать обычный параграф, и вставлять
      слова Note, Tip, Important, Warning, Caution или их локализованные варианты.
      https://docs.github.com/ru/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#alerts
      https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#alerts
- [ ] Сделать опцию командной строки, которая открывает временный каталог в проводнике, а то надоело его искать каждый раз руками, когда
      во вьювере что-то идёт не так, и надо посмотреть, как документ обрабатывается доксигеном.


## Баги

- [X] Баг с генерацией оглавления. 1) Оглавление почему-то генерируется в список с отступом. 2) На некоторых документах отступ получается слишком большим,
      и перестаёт восприниматься как список (и ссылки в нем перестают парсится как ссылки, по крайней мере в GitLab).
- [X] Баг с несколькими авторами. Пробовал, как в YAML: список с минусом спереди - вообще пропало, пробовал в одну строчку через запятую - второе имя почему-то в кавычках.
      Имена вида "Имя <add@domain.com>". 
      Пофиксил. Заодно поправил в других местах. Заодно поправил вывод пустого множества мета-тэгов (раньше выводилось '{}')/
      Добавил очистку списка выводимых тэгов - `--serialize-meta-tags=-`. Получается, что теперь можно двумя способами управлять выводом тэгов,
      второй способ - `--processing-options=no-meta-data`. Пофиксил баг, когда список commaList/commaSet не парсился, если он в виде списка.
- [ ] Есть подозрение, что есть проблемы с генерацией git-add файла - почему-то вроде бы сгенеренные картинки туда попадают, а документы - нет.
