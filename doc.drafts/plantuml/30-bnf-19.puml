@startebnf
Block = "{", [BlockStatements], "}";
BlockStatements = BlockStatement, {BlockStatement};
BlockStatement = LocalClassOrInterfaceDeclaration | LocalVariableDeclarationStatement | Statement;
LocalClassOrInterfaceDeclaration = ClassDeclaration | NormalInterfaceDeclaration;
LocalVariableDeclarationStatement = LocalVariableDeclaration, ";";
LocalVariableDeclaration = {VariableModifier}, LocalVariableType, VariableDeclaratorList;
LocalVariableType = UnannType | "var";
Statement = StatementWithoutTrailingSubstatement | LabeledStatement | IfThenStatement | IfThenElseStatement | WhileStatement | ForStatement;
StatementNoShortIf = StatementWithoutTrailingSubstatement | LabeledStatementNoShortIf | IfThenElseStatementNoShortIf | WhileStatementNoShortIf | ForStatementNoShortIf;
StatementWithoutTrailingSubstatement = Block | EmptyStatement | ExpressionStatement | AssertStatement | SwitchStatement | DoStatement | BreakStatement | ContinueStatement | ReturnStatement | SynchronizedStatement | ThrowStatement | TryStatement | YieldStatement;
EmptyStatement = ";";
LabeledStatement = Identifier, ":", Statement;
LabeledStatementNoShortIf = Identifier, ":", StatementNoShortIf;
ExpressionStatement = StatementExpression, ";";
StatementExpression = Assignment | PreIncrementExpression | PreDecrementExpression | PostIncrementExpression | PostDecrementExpression | MethodInvocation | ClassInstanceCreationExpression;
IfThenStatement = "if", "(", Expression, ")", Statement;
IfThenElseStatement = "if", "(", Expression, ")", StatementNoShortIf, "else", Statement;
IfThenElseStatementNoShortIf = "if", "(", Expression, ")", StatementNoShortIf, "else", StatementNoShortIf;
AssertStatement = ("assert", Expression, ";") | ("assert", Expression, ":", Expression, ";");
SwitchStatement = "switch", "(", Expression, ")", SwitchBlock;
SwitchBlock = ( "{", SwitchRule, {SwitchRule}, "}" ) | ( "{", {SwitchBlockStatementGroup}, {SwitchLabel, ":"}, "}" );
SwitchRule = (SwitchLabel, "->", Expression, ";") |(SwitchLabel, "->", Block) | (SwitchLabel, "->", ThrowStatement);
SwitchBlockStatementGroup = SwitchLabel, ":", {SwitchLabel, ":"}, BlockStatements;
SwitchLabel = ("case", CaseConstant, {",", CaseConstant}) | "default";
CaseConstant = ConditionalExpression;
WhileStatement = "while", "(", Expression, ")", Statement;
WhileStatementNoShortIf = "while", "(", Expression, ")", StatementNoShortIf;
DoStatement = "do", Statement, "while", "(", Expression, ")", ";";
ForStatement = BasicForStatement | EnhancedForStatement | ForStatementNoShortIf | BasicForStatementNoShortIf | EnhancedForStatementNoShortIf;
BasicForStatement = "for", "(", [ForInit], ";", [Expression], ";", [ForUpdate], ")", Statement;
BasicForStatementNoShortIf = "for", "(", [ForInit], ";", [Expression], ";", [ForUpdate], ")", StatementNoShortIf;
ForInit = StatementExpressionList | LocalVariableDeclaration;
ForUpdate = StatementExpressionList;
StatementExpressionList = StatementExpression, {",", StatementExpression};
EnhancedForStatement = "for", "(", LocalVariableDeclaration, ":", Expression, ")", Statement;
EnhancedForStatementNoShortIf = "for", "(", LocalVariableDeclaration, ":", Expression, ")", StatementNoShortIf;
BreakStatement = break, [Identifier], ";";
YieldStatement = "yield", Expression, ";";
ContinueStatement = "continue", [Identifier], ";";
ReturnStatement = "return" [Expression], ";";
ThrowStatement = "throw", Expression, ";";
SynchronizedStatement = "synchronized", "(", Expression, ")", Block;
TryStatement = ("try", Block, Catches) | ("try", Block, [Catches], Finally ) | TryWithResourcesStatement;
Catches = CatchClause, {CatchClause};
CatchClause = "catch", "(", CatchFormalParameter, ")", Block;
CatchFormalParameter = {VariableModifier}, CatchType, VariableDeclaratorId;
CatchType = UnannClassType, {"|", ClassType};
Finally = "finally", Block;
TryWithResourcesStatement = "try", ResourceSpecification, Block, [Catches], [Finally];
ResourceSpecification = "(", ResourceList, [";"], ")";
ResourceList = Resource, {";", Resource};
Resource = LocalVariableDeclaration | VariableAccess;
Pattern = TypePattern;
TypePattern = LocalVariableDeclaration;

(* Expressions *)

Primary = PrimaryNoNewArray | ArrayCreationExpression;
PrimaryNoNewArray = Literal | ClassLiteral | "this" | (TypeName, ".", "this") | ( "(", Expression, ")" ) | ClassInstanceCreationExpression | FieldAccess | ArrayAccess | MethodInvocation | MethodReference;
ClassLiteral = (TypeName, { "[", "]" }, ".", "class") | (NumericType, {"[", "]"}, ".", "class") | ("boolean", {"[", "]"}, ".", "class") | ("void", ".", "class");
ClassInstanceCreationExpression = UnqualifiedClassInstanceCreationExpression | (ExpressionName, ".", UnqualifiedClassInstanceCreationExpression) |(Primary, ".", UnqualifiedClassInstanceCreationExpression);
UnqualifiedClassInstanceCreationExpression = "new", [TypeArguments], ClassOrInterfaceTypeToInstantiate, "(", [ArgumentList], ")", [ClassBody];
ClassOrInterfaceTypeToInstantiate = {Annotation}, Identifier, {".", {Annotation}, Identifier}, [TypeArgumentsOrDiamond];
TypeArgumentsOrDiamond = TypeArguments | ("<",">");
ArrayCreationExpression = ArrayCreationExpressionWithoutInitializer | ArrayCreationExpressionWithInitializer;
ArrayCreationExpressionWithoutInitializer = ("new", PrimitiveType, DimExprs, [Dims]) | ("new", ClassOrInterfaceType, DimExprs, [Dims]);
ArrayCreationExpressionWithInitializer = ("new", PrimitiveType, Dims, ArrayInitializer) | ("new", ClassOrInterfaceType, Dims, ArrayInitializer);
DimExprs = DimExpr, {DimExpr};
DimExpr = ({Annotation}, [ Expression ]) | (ArrayAccess, "=", ExpressionName, "[", Expression, "]") | (PrimaryNoNewArray, "[", Expression, "]") | (ArrayCreationExpressionWithInitializer, "[", Expression, "]");
FieldAccess = (Primary, ".", Identifier), ("super", ".", Identifier), (TypeName, ".", super, ".", Identifier);
MethodInvocation = (MethodName, "(", [ArgumentList], ")") | (TypeName, ".", [TypeArguments], Identifier, "(", [ArgumentList], ")") | (ExpressionName, ".", [TypeArguments], Identifier, "(", [ArgumentList], ")") | (Primary, ".", [TypeArguments], Identifier, "(", [ArgumentList], ")") | ("super", ".", [TypeArguments], Identifier, "(", [ArgumentList], ")") | (TypeName, ".", "super", ".", [TypeArguments], Identifier, "(", [ArgumentList], ")");
ArgumentList = Expression, {",", Expression};
MethodReference = (ExpressionName, "::", [TypeArguments], Identifier) | (Primary, "::", [TypeArguments], Identifier) | (ReferenceType, "::", [TypeArguments], Identifier) | ("super", "::", [TypeArguments], Identifier) | (TypeName, ".", super, "::", [TypeArguments], Identifier) | (ClassType, "::", [TypeArguments], "new") | (ArrayType, "::", "new");
Expression = LambdaExpression | AssignmentExpression;
LambdaExpression = LambdaParameters, "->", LambdaBody;
LambdaParameters = ("(", [LambdaParameterList], ")") | Identifier;
LambdaParameterList = (LambdaParameter, {",", LambdaParameter}) | (Identifier, {",", Identifier});
LambdaParameter = ({VariableModifier}, LambdaParameterType, VariableDeclaratorId) | VariableArityParameter;
LambdaParameterType = UnannType | "var";
LambdaBody = Expression | Block;
AssignmentExpression = ConditionalExpression | Assignment;
Assignment = LeftHandSide | AssignmentOperator | Expression;
LeftHandSide = ExpressionName | FieldAccess | ArrayAccess;
AssignmentOperator = "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|=";
ConditionalExpression = ConditionalOrExpression | (ConditionalOrExpression, "?", Expression, ":", ConditionalExpression) | (ConditionalOrExpression, "?", Expression, ":", LambdaExpression);
ConditionalOrExpression = ConditionalAndExpression | (ConditionalOrExpression, "||", ConditionalAndExpression);
ConditionalAndExpression = InclusiveOrExpression | (ConditionalAndExpression, "&&", InclusiveOrExpression);
InclusiveOrExpression = ExclusiveOrExpression | (InclusiveOrExpression, "|", ExclusiveOrExpression);
ExclusiveOrExpression = AndExpression | (ExclusiveOrExpression, "^", AndExpression);
AndExpression = EqualityExpression, (AndExpression, "&", EqualityExpression) | (EqualityExpression, "=", RelationalExpression) | (EqualityExpression, "==", RelationalExpression) | (EqualityExpression, "!=", RelationalExpression);
RelationalExpression = ShiftExpression | (RelationalExpression, "<", ShiftExpression) | (RelationalExpression, ">", ShiftExpression) | (RelationalExpression, "<=", ShiftExpression) | (RelationalExpression, ">=", ShiftExpression) | (InstanceofExpression);
InstanceofExpression = (RelationalExpression, "instanceof", ReferenceType) | (RelationalExpression, "instanceof", Pattern);
ShiftExpression = AdditiveExpression | (ShiftExpression, "<<", AdditiveExpression) | (ShiftExpression, ">>", AdditiveExpression) | (ShiftExpression, ">>>", AdditiveExpression);
AdditiveExpression = MultiplicativeExpression | (AdditiveExpression, "+", MultiplicativeExpression) | (AdditiveExpression, "-", MultiplicativeExpression);
MultiplicativeExpression = UnaryExpression | (MultiplicativeExpression, "*", UnaryExpression) | (MultiplicativeExpression, "/", UnaryExpression) | (MultiplicativeExpression, "%", UnaryExpression);
UnaryExpression = PreIncrementExpression | PreDecrementExpression | ("+", UnaryExpression) | ("-", UnaryExpression) | UnaryExpressionNotPlusMinus;
PreIncrementExpression = "++", UnaryExpression;
PreDecrementExpression = "--", UnaryExpression;
UnaryExpressionNotPlusMinus = PostfixExpression | ("~", UnaryExpression) | ("!", UnaryExpression) | CastExpression | SwitchExpression;
PostfixExpression = Primary | ExpressionName | PostIncrementExpression | PostDecrementExpression;
PostIncrementExpression = PostfixExpression, "++";
PostDecrementExpression = PostfixExpression, "--";
CastExpression = ("(", PrimitiveType, ")", UnaryExpression) | ("(", ReferenceType, {AdditionalBound}, ")", UnaryExpressionNotPlusMinus) | ("(", ReferenceType, {AdditionalBound}, ")", LambdaExpression);
SwitchExpression = "switch", "(", Expression, ")", SwitchBlock;
ConstantExpression = Expression;
@endebnf
